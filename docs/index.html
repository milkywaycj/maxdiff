<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MaxDiff Analysis Tool</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .header p {
            opacity: 0.8;
            font-size: 0.95rem;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }
        
        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1a1a2e;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-upload {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #e9ecef;
            color: #495057;
        }
        
        .btn-secondary:hover {
            background: #dee2e6;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(17, 153, 142, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .file-name {
            padding: 10px 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            color: #495057;
            flex: 1;
            min-width: 200px;
        }
        
        .status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .status-pending {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-ready {
            background: #d4edda;
            color: #155724;
        }
        
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .option-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #495057;
            font-size: 0.9rem;
        }
        
        .option-group select,
        .option-group input[type="number"],
        .option-group input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }
        
        .option-group select:focus,
        .option-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .progress-container {
            margin-top: 20px;
        }
        
        .progress-bar {
            height: 24px;
            background: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
            font-size: 0.85rem;
            min-width: 40px;
        }
        
        .progress-status {
            text-align: center;
            color: #495057;
            font-size: 0.95rem;
        }
        
        .log-container {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-content {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            color: #a0a0a0;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .log-content .success {
            color: #38ef7d;
        }
        
        .log-content .error {
            color: #ff6b6b;
        }
        
        .log-content .info {
            color: #74b9ff;
        }
        
        .log-content .warning {
            color: #ffc107;
        }
        
        .results-container {
            display: none;
        }
        
        .results-container.show {
            display: block;
        }
        
        .result-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 10px 20px;
            border: none;
            background: #e9ecef;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
            font-weight: 600;
        }
        
        .tab-btn.segment-tab {
            background: #fff3cd;
            color: #856404;
        }
        
        .tab-btn.segment-tab.active {
            background: #ffc107;
            color: #1a1a2e;
        }
        
        .result-panel {
            display: none;
            background: white;
            border-radius: 0 12px 12px 12px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }
        
        .result-panel.active {
            display: block;
        }
        
        .chart-container {
            text-align: center;
            margin: 15px 0;
        }
        
        .chart-container img {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        
        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }
        
        .data-table tr:hover {
            background: #f8f9fa;
        }
        
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            gap: 20px;
        }
        
        .loading-overlay.show {
            display: flex;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            font-size: 1.1rem;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
        }
        
        .collapsible::before {
            content: '‚ñ∂';
            display: inline-block;
            margin-right: 8px;
            transition: transform 0.2s;
        }
        
        .collapsible.open::before {
            transform: rotate(90deg);
        }
        
        .collapsible-content {
            display: none;
            padding-top: 15px;
        }
        
        .collapsible-content.show {
            display: block;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 15px;
        }
        
        .info-box p {
            color: #495057;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        .download-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .segment-selector {
            margin-bottom: 15px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
        }
        
        .segment-selector label {
            font-weight: 600;
            margin-right: 10px;
        }
        
        .segment-selector select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ffc107;
            font-size: 0.9rem;
            margin-right: 10px;
        }
        
        .segment-info {
            display: inline-block;
            padding: 4px 12px;
            background: #ffc107;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.5rem;
            }
            
            .content {
                padding: 15px;
            }
            
            .file-upload {
                flex-direction: column;
                align-items: stretch;
            }
            
            .file-name {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Loading Python environment...</div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üìä MaxDiff Analysis Tool</h1>
            <p>by Carl J</p>
            <br>
            <p>Browser-based analysis ‚Ä¢ Your data stays local and private</p>
        </div>
        
        <div class="content">
            <!-- Data Format Guide -->
            <div class="section">
                <div class="section-title collapsible" onclick="toggleCollapsible(this)">
                    üìñ Data Format Guide
                </div>
                <div class="collapsible-content">
                    <div class="info-box">
                        <p><strong>Required format:</strong> Response ID | Attribute1 | Attribute2 | Attribute3 | ... | Most | Least</p>
                        <p style="margin-top: 10px;">
                            ‚Ä¢ <strong>Response ID:</strong> Participant identifier (can repeat for multiple tasks)<br>
                            ‚Ä¢ <strong>Attribute columns:</strong> Items shown in each choice task (minimum 3)<br>
                            ‚Ä¢ <strong>Most/Best:</strong> The item selected as most preferred<br>
                            ‚Ä¢ <strong>Least/Worst:</strong> The item selected as least preferred
                        </p>
                        <p style="margin-top: 10px;">
                            <strong>Segment file format:</strong> Response ID | SegmentColumn1 | SegmentColumn2 | ...<br>
                            ‚Ä¢ One row per respondent with Response ID matching the MaxDiff data
                        </p>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="downloadExampleMaxDiff()">
                            üì• Example MaxDiff CSV
                        </button>
                        <button class="btn btn-secondary" onclick="downloadExampleSegment()">
                            üì• Example Segment CSV
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Data Files -->
            <div class="section">
                <div class="section-title">üìÅ Data Files</div>
                
                <div style="margin-bottom: 15px;">
                    <label style="font-weight: 500; margin-bottom: 8px; display: block;">MaxDiff Data (Required)</label>
                    <div class="file-upload">
                        <input type="file" id="maxdiffFile" accept=".csv" onchange="handleMaxDiffFile(this)">
                        <button class="btn btn-primary" onclick="document.getElementById('maxdiffFile').click()">
                            üìÇ Browse
                        </button>
                        <span class="file-name" id="maxdiffFileName">No file selected</span>
                        <span class="status status-pending" id="maxdiffStatus">‚ö†Ô∏è Required</span>
                    </div>
                    <div id="dataInfo" style="margin-top: 8px; font-size: 0.9rem; color: #6c757d;"></div>
                </div>
                
                <div>
                    <label style="font-weight: 500; margin-bottom: 8px; display: block;">Segment Data (Optional - enables breakdown by groups)</label>
                    <div class="file-upload">
                        <input type="file" id="segmentFile" accept=".csv" onchange="handleSegmentFile(this)">
                        <button class="btn btn-secondary" onclick="document.getElementById('segmentFile').click()">
                            üìÇ Browse
                        </button>
                        <span class="file-name" id="segmentFileName">No file selected (optional)</span>
                        <span class="status" id="segmentStatus" style="color: #6c757d;">Optional</span>
                        <button class="btn btn-secondary" onclick="clearSegmentFile()" style="padding: 8px 12px;">‚úï</button>
                    </div>
                    <div id="segmentInfo" style="margin-top: 8px; font-size: 0.9rem; color: #6c757d;"></div>
                </div>
            </div>
            
            <!-- Analysis Options -->
            <div class="section">
                <div class="section-title collapsible" onclick="toggleCollapsible(this)">
                    ‚öôÔ∏è Analysis Options
                </div>
                <div class="collapsible-content">
                    <div class="options-grid">
                        <div class="option-group">
                            <label>Output Labels</label>
                            <select id="outputTerms">
                                <option value="Best/Worst">Best / Worst</option>
                                <option value="Most/Least">Most / Least</option>
                            </select>
                        </div>
                        
                        <div class="option-group">
                            <label>Bootstrap Iterations</label>
                            <input type="number" id="iterations" value="10000" min="100" max="50000">
                        </div>
                        
                        <div class="option-group">
                            <label>Anchor Item (Optional)</label>
                            <input type="text" id="anchorItem" placeholder="Item to highlight">
                        </div>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="includeCI" checked>
                        <label for="includeCI">Include 95% Confidence Intervals (Bootstrap)</label>
                    </div>
                    
                    <div class="info-box" style="margin-top: 15px; background: #fff3cd; border-color: #ffc107;">
                        <p><strong>Note:</strong> About the analysis method: This tool uses count-based analysis with bootstrap confidence intervals. Research shows count-based scores correlate r = 0.99+ with Hierarchical Bayes utilities for standard balanced designs‚Äîyou'll get the same rankings with greater transparency. HB is only necessary when you need individual-level utilities for follow-up analyses like latent class segmentation, TURF optimization, or personalization. Hierarchical Bayes analysis is not available in the browser version of this tool.</p>
                    </div>
                </div>
            </div>
            
            <!-- Run Analysis -->
            <div class="section">
                <div class="section-title">üöÄ Run Analysis</div>
                
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-success" id="runBtn" onclick="runAnalysis()" disabled>
                        üöÄ Run Analysis
                    </button>
                    <button class="btn btn-secondary" id="downloadBtn" onclick="downloadAllResults()" style="display: none;">
                        üì• Download All Results
                    </button>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%;">0%</div>
                    </div>
                    <div class="progress-status" id="progressStatus">Ready</div>
                </div>
            </div>
            
            <!-- Log -->
            <div class="section">
                <div class="section-title">üìã Analysis Log</div>
                <div class="log-container">
                    <div class="log-content" id="logContent">Waiting to start...</div>
                </div>
            </div>
            
            <!-- Results -->
            <div class="section results-container" id="resultsContainer">
                <div class="section-title">üìä Results</div>
                
                <!-- Segment selector (shown when segments are available) -->
                <div class="segment-selector" id="segmentSelector" style="display: none;">
                    <label>üìä View Results For:</label>
                    <select id="segmentDropdown" onchange="switchSegmentView()">
                        <option value="overall">Overall (All Respondents)</option>
                    </select>
                    <span class="segment-info" id="currentSegmentInfo"></span>
                </div>
                
                <div class="result-tabs" id="resultTabs">
                    <button class="tab-btn active" onclick="showTab('scores')">Net Scores</button>
                    <button class="tab-btn" onclick="showTab('frequencies')">Selection Frequencies</button>
                    <button class="tab-btn" onclick="showTab('balance')">Display Balance</button>
                    <button class="tab-btn" onclick="showTab('data')">Data Tables</button>
                </div>
                
                <div class="result-panel active" id="panel-scores">
                    <div class="chart-container" id="scoresChart"></div>
                </div>
                
                <div class="result-panel" id="panel-frequencies">
                    <div class="chart-container" id="frequenciesChart"></div>
                </div>
                
                <div class="result-panel" id="panel-balance">
                    <div class="chart-container" id="balanceChart"></div>
                </div>
                
                <div class="result-panel" id="panel-data">
                    <h4 style="margin-bottom: 15px;">Net Scores</h4>
                    <div id="scoresTable"></div>
                    
                    <h4 style="margin: 25px 0 15px;">Display Statistics</h4>
                    <div id="displayTable"></div>
                    
                    <div class="download-buttons">
                        <button class="btn btn-secondary" onclick="downloadCSV('scores')">üì• Download Scores CSV</button>
                        <button class="btn btn-secondary" onclick="downloadCSV('frequencies')">üì• Download Frequencies CSV</button>
                        <button class="btn btn-secondary" onclick="downloadCSV('display')">üì• Download Display Stats CSV</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let worker = null;
        let pyodideReady = false;
        let maxdiffDataJson = null;
        let segmentDataJson = null;
        let analysisResults = null;
        let currentSegmentView = 'overall';
        
        // Python code as a string (will be sent to worker)
        const PYTHON_CODE = `
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import seaborn as sns
import textwrap
import io
import base64
import json
from collections import defaultdict

# ============================================================================
# DISPLAY STATISTICS & BALANCE CHECKING
# ============================================================================

def calculate_display_statistics(df, attribute_columns, pos_col, neg_col):
    unique_items = pd.unique(df[attribute_columns].values.ravel())
    unique_items = [item for item in unique_items if pd.notna(item)]
    
    stats = []
    for item in unique_items:
        displays = (df[attribute_columns] == item).sum().sum()
        pos_count = (df[pos_col] == item).sum()
        neg_count = (df[neg_col] == item).sum()
        
        stats.append({
            'Item': item,
            'Times Displayed': int(displays),
            'Times Selected Best': int(pos_count),
            'Times Selected Worst': int(neg_count),
            'Times Unselected': int(displays - pos_count - neg_count),
            'Best Rate': float(pos_count / displays) if displays > 0 else 0.0,
            'Worst Rate': float(neg_count / displays) if displays > 0 else 0.0,
        })
    
    stats_df = pd.DataFrame(stats).sort_values('Times Displayed', ascending=False)
    
    display_counts = stats_df['Times Displayed'].values
    mean_displays = display_counts.mean() if len(display_counts) > 0 else 0
    std_displays = display_counts.std() if len(display_counts) > 0 else 0
    
    balance_metrics = {
        'total_displays': int(display_counts.sum()),
        'num_items': len(unique_items),
        'min_displays': int(display_counts.min()) if len(display_counts) > 0 else 0,
        'max_displays': int(display_counts.max()) if len(display_counts) > 0 else 0,
        'mean_displays': float(mean_displays),
        'std_displays': float(std_displays),
        'cv_displays': float(std_displays / mean_displays) if mean_displays > 0 else 0,
    }
    
    return stats_df, balance_metrics


def format_display_report(stats_df, balance_metrics, output_terms):
    pos_label, neg_label = output_terms
    
    lines = []
    lines.append("=" * 50)
    lines.append("DISPLAY STATISTICS REPORT")
    lines.append("=" * 50)
    lines.append("")
    lines.append(f"Total items: {balance_metrics['num_items']}")
    lines.append(f"Total displays: {balance_metrics['total_displays']:,}")
    lines.append(f"Mean displays per item: {balance_metrics['mean_displays']:.1f}")
    lines.append(f"Coefficient of variation: {balance_metrics['cv_displays']:.1%}")
    lines.append("")
    
    return "\\n".join(lines)


# ============================================================================
# ANALYSIS FUNCTIONS
# ============================================================================

def check_errors(df, attribute_columns, pos_col, neg_col):
    if len(attribute_columns) < 3:
        raise ValueError("Less than 3 attributes found")
    columns_to_check = attribute_columns + [pos_col, neg_col]
    if df[columns_to_check].isnull().any().any():
        raise ValueError(f"Missing data in {pos_col}, {neg_col}, or attribute columns")
    for idx, row in df.iterrows():
        displayed_attributes = set(row[attribute_columns])
        if row[pos_col] not in displayed_attributes:
            raise ValueError(f"Row {idx}: Selection '{row[pos_col]}' not in displayed attributes")
        if row[neg_col] not in displayed_attributes:
            raise ValueError(f"Row {idx}: Selection '{row[neg_col]}' not in displayed attributes")


def calculate_observed_percentages(df, attribute_columns, pos_col, neg_col, output_terms):
    pos_label, neg_label = output_terms
    results = []
    unique_items = pd.unique(df[attribute_columns].values.ravel())
    unique_items = [item for item in unique_items if pd.notna(item)]
    
    for item in unique_items:
        item_displays = (df[attribute_columns] == item).sum().sum()
        pos_count = (df[pos_col] == item).sum()
        neg_count = (df[neg_col] == item).sum()
        unselected_count = item_displays - pos_count - neg_count
        results.append({
            'Item': item,
            f'% Selected as {pos_label}': float(pos_count / item_displays * 100) if item_displays > 0 else 0.0,
            '% Unselected': float(unselected_count / item_displays * 100) if item_displays > 0 else 0.0,
            f'% Selected as {neg_label}': float(neg_count / item_displays * 100) if item_displays > 0 else 0.0,
            'Score': float((pos_count - neg_count) / item_displays * 100) if item_displays > 0 else 0.0
        })
    return pd.DataFrame(results).sort_values('Score', ascending=False)


def calculate_scores_no_ci(df, attribute_columns, pos_col, neg_col):
    unique_attributes = pd.unique(df[attribute_columns].values.ravel())
    unique_attributes = [attr for attr in unique_attributes if pd.notna(attr)]
    results = []
    for item in unique_attributes:
        item_displays = (df[attribute_columns] == item).sum().sum()
        pos_count = (df[pos_col] == item).sum()
        neg_count = (df[neg_col] == item).sum()
        results.append({
            'Item': item, 
            'Score': float((pos_count - neg_count) / item_displays * 100) if item_displays > 0 else 0.0
        })
    return pd.DataFrame(results).sort_values('Score', ascending=False)


def perform_maxdiff_analysis(attribute_data, pos_data, neg_data, unique_attributes):
    n_attributes = len(unique_attributes)
    
    display_count = np.zeros(n_attributes, dtype=np.float64)
    for i in range(n_attributes):
        display_count[i] = np.sum(attribute_data == i)
    
    pos_data_int = np.array(pos_data, dtype=np.int64).ravel()
    neg_data_int = np.array(neg_data, dtype=np.int64).ravel()
    
    pos_count = np.zeros(n_attributes, dtype=np.float64)
    neg_count = np.zeros(n_attributes, dtype=np.float64)
    
    for i in range(n_attributes):
        pos_count[i] = np.sum(pos_data_int == i)
        neg_count[i] = np.sum(neg_data_int == i)
    
    with np.errstate(divide='ignore', invalid='ignore'):
        score = np.where(display_count > 0, 
                        ((pos_count / display_count) - (neg_count / display_count)) * 100, 
                        0)
    
    return pd.DataFrame({'Item': unique_attributes, 'Score': score})


def bootstrap_analysis(df, attribute_columns, unique_attributes, attr_to_index, 
                       pos_col, neg_col, n_iterations=10000, progress_callback=None,
                       progress_offset=0.0, progress_scale=1.0):
    unique_participants = df['Response ID'].unique()
    n_participants = len(unique_participants)
    n_attributes = len(unique_attributes)
    df_reset = df.reset_index(drop=True)
    
    attribute_data = df_reset[attribute_columns].replace(attr_to_index).values.astype(np.int64)
    pos_data = df_reset[pos_col].replace(attr_to_index).values.astype(np.int64)
    neg_data = df_reset[neg_col].replace(attr_to_index).values.astype(np.int64)
    
    participant_indices = df_reset.groupby('Response ID').indices
    
    observed_results = perform_maxdiff_analysis(attribute_data, pos_data, neg_data, unique_attributes)
    observed_scores = observed_results.set_index('Item')['Score']
    
    all_scores = np.zeros((n_iterations, n_attributes))
    rng = np.random.default_rng()
    
    update_interval = max(1, n_iterations // 100)
    
    for i in range(n_iterations):
        sampled_participants = rng.choice(unique_participants, size=n_participants, replace=True)
        sampled_indices = np.concatenate([participant_indices[p] for p in sampled_participants])
        results = perform_maxdiff_analysis(
            attribute_data[sampled_indices], 
            pos_data[sampled_indices], 
            neg_data[sampled_indices], 
            unique_attributes
        )
        all_scores[i] = results['Score'].values
        if progress_callback and i % update_interval == 0:
            progress = progress_offset + (i / n_iterations) * progress_scale
            progress_callback(progress)
    
    if progress_callback:
        progress_callback(progress_offset + progress_scale)
    
    percentile_2_5 = np.percentile(all_scores, 2.5, axis=0)
    percentile_97_5 = np.percentile(all_scores, 97.5, axis=0)
    obs_scores_array = observed_scores[unique_attributes].values
    
    return pd.DataFrame({
        'Item': unique_attributes, 
        'Score': obs_scores_array,
        '2.5th Percentile': percentile_2_5, 
        '97.5th Percentile': percentile_97_5,
        'Negative Error': obs_scores_array - percentile_2_5,
        'Positive Error': percentile_97_5 - obs_scores_array
    }).sort_values('Score', ascending=False)


# ============================================================================
# PLOTTING FUNCTIONS
# ============================================================================

def plot_observed_percentages(df, title, output_terms):
    pos_label, neg_label = output_terms
    pos_col = f'% Selected as {pos_label}'
    neg_col = f'% Selected as {neg_label}'
    df = df.sort_values('Score', ascending=True)
    fig, ax = plt.subplots(figsize=(12, max(4, len(df) * 0.4)))
    y_pos = range(len(df))
    ax.barh(y_pos, df[pos_col], color='#FFC000', label=pos_col)
    ax.barh(y_pos, df['% Unselected'], left=df[pos_col], color='#D9D9D9', label='% Unselected')
    ax.barh(y_pos, df[neg_col], left=df[pos_col] + df['% Unselected'], color='#5B9BD5', label=neg_col)
    ax.set_yticks(y_pos)
    ax.set_yticklabels(df['Item'], fontsize=8)
    ax.set_title(title)
    ax.legend(loc='lower right', bbox_to_anchor=(1, -0.1), ncol=3)
    
    for i, (pos, unsel, neg) in enumerate(zip(df[pos_col], df['% Unselected'], df[neg_col])):
        if pos > 5:
            ax.text(pos/2, i, f'{pos:.0f}%', va='center', ha='center', fontsize=8)
        if unsel > 5:
            ax.text(pos + unsel/2, i, f'{unsel:.0f}%', va='center', ha='center', fontsize=8)
        if neg > 5:
            ax.text(100 - neg/2, i, f'{neg:.0f}%', va='center', ha='center', fontsize=8)
    
    plt.tight_layout()
    return fig


def plot_scores(results, title="MaxDiff Scores", sample_size=None, anchor_item=None, include_ci=True):
    positive_color = '#f4b400'
    negative_color = '#f4b400'
    error_bar_color = '#a1a1a1'
    zero_line_color = 'red'
    anchor_item_color = '#a1a1a1'
    
    sorted_results = results.sort_values('Score', ascending=True).reset_index(drop=True)
    num_items = len(sorted_results)
    fig, ax = plt.subplots(figsize=(13, max(0.4 * num_items, 6)), dpi=100)
    wrapped_labels = [textwrap.fill(str(label), width=50) for label in sorted_results['Item']]
    has_ci = include_ci and 'Negative Error' in sorted_results.columns and 'Positive Error' in sorted_results.columns
    
    for i, row in sorted_results.iterrows():
        item = row['Item']
        score = row['Score']
        
        if item == anchor_item:
            point_color = anchor_item_color
            error_color = anchor_item_color
        else:
            point_color = positive_color if score >= 0 else negative_color
            error_color = error_bar_color
        
        if has_ci:
            neg_err = row['Negative Error']
            pos_err = row['Positive Error']
            ax.errorbar(score, i, xerr=[[neg_err], [pos_err]], fmt='o', capsize=5, 
                       capthick=2, color=point_color, markersize=8, ecolor=error_color, elinewidth=2)
        else:
            ax.plot(score, i, 'o', color=point_color, markersize=8)
    
    if sample_size:
        title += f" (n={sample_size})"
    
    ax.set_title(title, fontsize=16, pad=20)
    ax.set_xlabel('Score', fontsize=12)
    ax.set_yticks(range(len(sorted_results)))
    ax.set_yticklabels(wrapped_labels, fontsize=11)
    ax.grid(True, axis='x', linestyle='--', alpha=0.7)
    ax.axvline(x=0, color=zero_line_color, linestyle='--', alpha=0.5)
    plt.tight_layout()
    return fig


def plot_display_balance(stats_df, title="Item Display Frequency", output_terms=("Best", "Worst")):
    pos_label, neg_label = output_terms
    
    stats_sorted = stats_df.sort_values('Times Displayed', ascending=True)
    
    fig, axes = plt.subplots(1, 2, figsize=(14, max(6, len(stats_df) * 0.3)))
    
    ax1 = axes[0]
    mean_val = stats_df['Times Displayed'].mean()
    colors = ['#4CAF50' if x >= mean_val else '#FF9800' 
              for x in stats_sorted['Times Displayed']]
    
    y_pos = range(len(stats_sorted))
    ax1.barh(y_pos, stats_sorted['Times Displayed'], color=colors, edgecolor='white')
    
    ax1.set_yticks(y_pos)
    ax1.set_yticklabels([str(x)[:30] for x in stats_sorted['Item']], fontsize=9)
    ax1.set_xlabel('Times Displayed')
    ax1.set_title('Display Frequency per Item')
    
    ax1.axvline(x=mean_val, color='red', linestyle='--', linewidth=2, label=f'Mean: {mean_val:.0f}')
    ax1.legend(loc='lower right')
    
    ax2 = axes[1]
    
    bar_height = 0.35
    y_pos_arr = np.arange(len(stats_sorted))
    
    ax2.barh(y_pos_arr - bar_height/2, stats_sorted['Best Rate'] * 100, bar_height,
            label=f'% {pos_label}', color='#FFC000')
    ax2.barh(y_pos_arr + bar_height/2, stats_sorted['Worst Rate'] * 100, bar_height,
            label=f'% {neg_label}', color='#5B9BD5')
    
    ax2.set_yticks(y_pos_arr)
    ax2.set_yticklabels([str(x)[:30] for x in stats_sorted['Item']], fontsize=9)
    ax2.set_xlabel('Selection Rate (%)')
    ax2.set_title('Selection Rates per Item')
    ax2.legend(loc='lower right')
    ax2.set_xlim(0, 100)
    
    plt.suptitle(title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    
    return fig


def fig_to_base64(fig):
    buf = io.BytesIO()
    fig.savefig(buf, format='png', dpi=150, bbox_inches='tight')
    buf.seek(0)
    img_base64 = base64.b64encode(buf.read()).decode('utf-8')
    plt.close(fig)
    return img_base64


# ============================================================================
# SEGMENT ANALYSIS FUNCTION
# ============================================================================

def analyze_segment(segment_data, attribute_columns, unique_attributes, attr_to_index,
                   pos_col, neg_col, output_terms, include_ci, n_iterations,
                   progress_callback, progress_offset, progress_scale, log_callback,
                   segment_name):
    
    sample_size = segment_data['Response ID'].nunique()
    
    seg_display_stats, seg_balance = calculate_display_statistics(
        segment_data, attribute_columns, pos_col, neg_col
    )
    
    if include_ci and n_iterations > 0:
        segment_results = bootstrap_analysis(
            segment_data, attribute_columns, unique_attributes,
            attr_to_index, pos_col, neg_col, n_iterations, 
            progress_callback, progress_offset, progress_scale
        )
    else:
        segment_results = calculate_scores_no_ci(segment_data, attribute_columns, pos_col, neg_col)
        if progress_callback:
            progress_callback(progress_offset + progress_scale)
    
    segment_observed = calculate_observed_percentages(
        segment_data, attribute_columns, pos_col, neg_col, output_terms
    )
    
    scores_fig = plot_scores(
        segment_results, 
        f"MaxDiff Net Scores - {segment_name}", 
        sample_size, None, include_ci
    )
    
    freq_fig = plot_observed_percentages(
        segment_observed, 
        f"Selection Frequencies - {segment_name} (n={sample_size})", 
        output_terms
    )
    
    balance_fig = plot_display_balance(
        seg_display_stats, 
        f"Display Balance - {segment_name} (n={sample_size})",
        output_terms
    )
    
    return {
        'sample_size': int(sample_size),
        'scores_data': segment_results.to_dict('records'),
        'frequencies_data': segment_observed.to_dict('records'),
        'display_data': seg_display_stats.to_dict('records'),
        'scores_chart': fig_to_base64(scores_fig),
        'frequencies_chart': fig_to_base64(freq_fig),
        'balance_chart': fig_to_base64(balance_fig),
    }


# ============================================================================
# MAIN ANALYSIS FUNCTION
# ============================================================================

def run_maxdiff_analysis(data_list, segment_list, options, progress_callback, log_callback):
    
    results = {
        'overall': {},
        'segments': {},
        'segment_columns': []
    }
    
    try:
        log_callback("Parsing data...")
        df = pd.DataFrame(data_list)
        
        segment_df = None
        segment_columns = []
        if segment_list and len(segment_list) > 0:
            segment_df = pd.DataFrame(segment_list)
            segment_columns = [col for col in segment_df.columns if col != 'Response ID']
            log_callback(f"Segment data loaded: {len(segment_columns)} segment variable(s)")
            results['segment_columns'] = segment_columns
        
        pos_col, neg_col = 'Most', 'Least'
        if 'Best' in df.columns:
            pos_col, neg_col = 'Best', 'Worst'
        
        attribute_columns = [c for c in df.columns if c.startswith('Attribute')]
        
        log_callback("Validating data...")
        check_errors(df, attribute_columns, pos_col, neg_col)
        
        unique_attributes = pd.unique(df[attribute_columns].values.ravel('K'))
        unique_attributes = unique_attributes[~pd.isnull(unique_attributes)]
        unique_attributes = list(unique_attributes)
        attr_to_index = {attr: i for i, attr in enumerate(unique_attributes)}
        
        overall_sample_size = df['Response ID'].nunique()
        output_terms = tuple(options['output_terms'].split('/'))
        include_ci = options['include_ci']
        n_iterations = options['iterations']
        anchor_item = options['anchor_item'] if options['anchor_item'] else None
        
        log_callback(f"Found {len(unique_attributes)} items, {overall_sample_size} participants")
        
        total_segments = 1
        if segment_df is not None:
            for col in segment_columns:
                total_segments += len(df.merge(segment_df, on='Response ID')[col].dropna().unique())
        
        current_segment_idx = 0
        
        log_callback("\\n" + "=" * 50)
        log_callback("OVERALL ANALYSIS")
        log_callback("=" * 50)
        
        log_callback("Calculating display statistics...")
        display_stats_df, balance_metrics = calculate_display_statistics(
            df, attribute_columns, pos_col, neg_col
        )
        report = format_display_report(display_stats_df, balance_metrics, output_terms)
        log_callback(report)
        
        progress_scale = 0.6 / total_segments
        progress_offset = 0.05
        
        if include_ci:
            log_callback(f"Bootstrap analysis ({n_iterations:,} iterations)...")
            overall_results = bootstrap_analysis(
                df, attribute_columns, unique_attributes,
                attr_to_index, pos_col, neg_col, n_iterations, 
                progress_callback, progress_offset, progress_scale
            )
        else:
            log_callback("Calculating scores (no CI)...")
            overall_results = calculate_scores_no_ci(df, attribute_columns, pos_col, neg_col)
            progress_callback(progress_offset + progress_scale)
        
        current_segment_idx += 1
        
        log_callback("Calculating selection frequencies...")
        overall_observed = calculate_observed_percentages(
            df, attribute_columns, pos_col, neg_col, output_terms
        )
        
        log_callback("Generating charts...")
        
        scores_fig = plot_scores(overall_results, "MaxDiff Net Scores", 
                                overall_sample_size, anchor_item, include_ci)
        freq_fig = plot_observed_percentages(overall_observed, 
                                            f"Selection Frequencies (n={overall_sample_size})", 
                                            output_terms)
        balance_fig = plot_display_balance(display_stats_df, 
                                          f"Display Balance (n={overall_sample_size})",
                                          output_terms)
        
        results['overall'] = {
            'sample_size': int(overall_sample_size),
            'scores_data': overall_results.to_dict('records'),
            'frequencies_data': overall_observed.to_dict('records'),
            'display_data': display_stats_df.to_dict('records'),
            'scores_chart': fig_to_base64(scores_fig),
            'frequencies_chart': fig_to_base64(freq_fig),
            'balance_chart': fig_to_base64(balance_fig),
        }
        
        if segment_df is not None and len(segment_columns) > 0:
            log_callback("\\n" + "=" * 50)
            log_callback("SEGMENT ANALYSIS")
            log_callback("=" * 50)
            
            merged_df = pd.merge(df, segment_df, on='Response ID', how='left')
            
            for column in segment_columns:
                log_callback(f"\\nProcessing segment column: {column}")
                results['segments'][column] = {}
                
                unique_values = merged_df[column].dropna().unique()
                log_callback(f"  Found {len(unique_values)} segments: {list(unique_values)}")
                
                for segment_value in unique_values:
                    segment_data = merged_df[merged_df[column] == segment_value].copy()
                    
                    if len(segment_data) == 0:
                        continue
                    
                    segment_name = f"{column}: {segment_value}"
                    log_callback(f"  Analyzing: {segment_name}...")
                    
                    progress_offset = 0.05 + (current_segment_idx / total_segments) * 0.6
                    progress_scale = 0.6 / total_segments
                    
                    try:
                        segment_result = analyze_segment(
                            segment_data, attribute_columns, unique_attributes, attr_to_index,
                            pos_col, neg_col, output_terms, include_ci, n_iterations,
                            progress_callback, progress_offset, progress_scale, log_callback,
                            segment_name
                        )
                        
                        results['segments'][column][str(segment_value)] = segment_result
                        log_callback(f"    Complete: {segment_name}: n={segment_result['sample_size']}")
                        
                    except Exception as seg_error:
                        log_callback(f"    Error in {segment_name}: {str(seg_error)}")
                    
                    current_segment_idx += 1
        
        progress_callback(0.95)
        
        log_callback("\\n" + "=" * 50)
        log_callback("ANALYSIS COMPLETE!")
        log_callback("=" * 50)
        
        if segment_df is not None:
            total_segs = sum(len(v) for v in results['segments'].values())
            log_callback(f"  Overall analysis + {total_segs} segment analyses completed")
        
        progress_callback(1.0)
        
        results['success'] = True
        
    except Exception as e:
        import traceback
        log_callback(f"\\nERROR: {str(e)}")
        log_callback(traceback.format_exc())
        results['success'] = False
        results['error'] = str(e)
    
    return results
`;

        // Create Web Worker from inline code
        function createWorker() {
            const workerCode = `
importScripts('https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js');

let pyodide = null;

async function initPyodide(pythonCode) {
    self.postMessage({ type: 'status', message: 'Loading Python environment...' });
    
    try {
        pyodide = await loadPyodide();
        
        self.postMessage({ type: 'status', message: 'Installing numpy...' });
        await pyodide.loadPackage('numpy');
        
        self.postMessage({ type: 'status', message: 'Installing pandas...' });
        await pyodide.loadPackage('pandas');
        
        self.postMessage({ type: 'status', message: 'Installing matplotlib...' });
        await pyodide.loadPackage('matplotlib');
        
        self.postMessage({ type: 'status', message: 'Installing micropip...' });
        await pyodide.loadPackage('micropip');
        
        self.postMessage({ type: 'status', message: 'Installing seaborn...' });
        const micropip = pyodide.pyimport('micropip');
        await micropip.install('seaborn');
        
        self.postMessage({ type: 'status', message: 'Loading analysis code...' });
        await pyodide.runPythonAsync(pythonCode);
        
        self.postMessage({ type: 'ready' });
        
    } catch (error) {
        self.postMessage({ type: 'error', message: error.toString() });
    }
}

async function runAnalysis(data, segmentData, options) {
    try {
        // Set up callbacks that post messages to main thread
        pyodide.globals.set('js_progress', (value) => {
            self.postMessage({ type: 'progress', value: value });
        });
        
        pyodide.globals.set('js_log', (message) => {
            self.postMessage({ type: 'log', message: message });
        });
        
        // Pass data to Python
        pyodide.globals.set('js_data', pyodide.toPy(data));
        pyodide.globals.set('js_segment_data', pyodide.toPy(segmentData));
        pyodide.globals.set('js_options', pyodide.toPy(options));
        
        // Run analysis
        const resultProxy = await pyodide.runPythonAsync(
            'run_maxdiff_analysis(js_data, js_segment_data, js_options, js_progress, js_log)'
        );
        
        // Convert result to JS - need to handle nested structures
        const result = resultProxy.toJs({dict_converter: Object.fromEntries});
        
        // Deep convert any remaining Map objects
        const cleanResult = deepConvertMaps(result);
        
        self.postMessage({ type: 'complete', result: cleanResult });
        
    } catch (error) {
        self.postMessage({ type: 'error', message: error.toString() });
    }
}

function deepConvertMaps(obj) {
    if (obj instanceof Map) {
        const result = {};
        for (const [key, value] of obj.entries()) {
            result[key] = deepConvertMaps(value);
        }
        return result;
    } else if (Array.isArray(obj)) {
        return obj.map(item => deepConvertMaps(item));
    } else if (obj !== null && typeof obj === 'object') {
        const result = {};
        for (const key of Object.keys(obj)) {
            result[key] = deepConvertMaps(obj[key]);
        }
        return result;
    }
    return obj;
}

self.onmessage = async (e) => {
    if (e.data.type === 'init') {
        await initPyodide(e.data.pythonCode);
    } else if (e.data.type === 'run') {
        await runAnalysis(e.data.data, e.data.segmentData, e.data.options);
    }
};
`;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }
        
        // Initialize worker
        function initWorker() {
            showLoading(true, 'Initializing...');
            
            worker = createWorker();
            
            worker.onmessage = (e) => {
                switch (e.data.type) {
                    case 'status':
                        document.getElementById('loadingText').textContent = e.data.message;
                        break;
                        
                    case 'ready':
                        pyodideReady = true;
                        showLoading(false);
                        log('‚úì Python environment ready', 'success');
                        break;
                        
                    case 'progress':
                        const percent = Math.round(e.data.value * 100);
                        updateProgress(e.data.value, `Processing... ${percent}%`);
                        break;
                        
                    case 'log':
                        log(e.data.message, 'info');
                        break;
                        
                    case 'complete':
                        analysisResults = e.data.result;
                        if (analysisResults.success) {
                            displayResults();
                            document.getElementById('downloadBtn').style.display = 'inline-flex';
                            log('\n‚úÖ Results ready! Use the dropdown to view segment breakdowns.', 'success');
                        } else {
                            log('Analysis failed: ' + analysisResults.error, 'error');
                        }
                        document.getElementById('runBtn').disabled = false;
                        document.getElementById('runBtn').textContent = 'üöÄ Run Analysis';
                        break;
                        
                    case 'error':
                        log('Error: ' + e.data.message, 'error');
                        document.getElementById('runBtn').disabled = false;
                        document.getElementById('runBtn').textContent = 'üöÄ Run Analysis';
                        showLoading(false);
                        break;
                }
            };
            
            worker.onerror = (e) => {
                log('Worker error: ' + e.message, 'error');
                showLoading(false);
            };
            
            // Send Python code to worker for initialization
            worker.postMessage({ type: 'init', pythonCode: PYTHON_CODE });
        }
        
        // Parse CSV to array of objects
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = parseCSVLine(lines[0]);
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim()) {
                    const values = parseCSVLine(lines[i]);
                    const row = {};
                    headers.forEach((header, j) => {
                        row[header] = values[j] || '';
                    });
                    data.push(row);
                }
            }
            return data;
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }
        
        // File handling
        async function handleMaxDiffFile(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            document.getElementById('maxdiffFileName').textContent = file.name;
            
            try {
                const text = await file.text();
                const data = parseCSV(text);
                
                if (data.length === 0) {
                    throw new Error('No data found in file');
                }
                
                const columns = Object.keys(data[0]);
                if (!columns.includes('Response ID')) {
                    throw new Error('Missing "Response ID" column');
                }
                
                const attrCols = columns.filter(c => c.startsWith('Attribute'));
                if (attrCols.length < 3) {
                    throw new Error('Need at least 3 Attribute columns');
                }
                
                if (!columns.includes('Most') && !columns.includes('Best')) {
                    throw new Error('Missing "Most" or "Best" column');
                }
                
                if (!columns.includes('Least') && !columns.includes('Worst')) {
                    throw new Error('Missing "Least" or "Worst" column');
                }
                
                maxdiffDataJson = data;
                
                const participants = [...new Set(data.map(r => r['Response ID']))].length;
                const items = [...new Set(data.flatMap(r => attrCols.map(c => r[c])))].filter(Boolean);
                
                document.getElementById('maxdiffStatus').textContent = '‚úì Ready';
                document.getElementById('maxdiffStatus').className = 'status status-ready';
                document.getElementById('dataInfo').innerHTML = 
                    `üìä ${participants} participants, ${data.length} tasks, ${items.length} items, ${attrCols.length} per task`;
                document.getElementById('runBtn').disabled = !pyodideReady;
                
                log(`‚úì Data loaded: ${participants} participants, ${items.length} items`, 'success');
                
            } catch (error) {
                log('Error loading file: ' + error.message, 'error');
                document.getElementById('maxdiffStatus').textContent = '‚ùå Error';
                document.getElementById('maxdiffStatus').className = 'status status-pending';
                maxdiffDataJson = null;
            }
        }
        
        async function handleSegmentFile(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            document.getElementById('segmentFileName').textContent = file.name;
            
            try {
                const text = await file.text();
                const data = parseCSV(text);
                
                if (data.length === 0) {
                    throw new Error('No data found in segment file');
                }
                
                const columns = Object.keys(data[0]);
                if (!columns.includes('Response ID')) {
                    throw new Error('Segment file must have "Response ID" column');
                }
                
                const segmentCols = columns.filter(c => c !== 'Response ID');
                if (segmentCols.length === 0) {
                    throw new Error('No segment columns found (columns other than Response ID)');
                }
                
                segmentDataJson = data;
                
                document.getElementById('segmentStatus').textContent = '‚úì Loaded';
                document.getElementById('segmentStatus').style.color = '#28a745';
                document.getElementById('segmentInfo').innerHTML = 
                    `üìä ${data.length} respondents, ${segmentCols.length} segment variable(s): ${segmentCols.join(', ')}`;
                
                log(`‚úì Segment file loaded: ${segmentCols.length} variables (${segmentCols.join(', ')})`, 'success');
                
            } catch (error) {
                log('Error loading segment file: ' + error.message, 'error');
                document.getElementById('segmentStatus').textContent = '‚ùå Error';
                document.getElementById('segmentStatus').style.color = '#dc3545';
                segmentDataJson = null;
            }
        }
        
        function clearSegmentFile() {
            document.getElementById('segmentFile').value = '';
            document.getElementById('segmentFileName').textContent = 'No file selected (optional)';
            document.getElementById('segmentStatus').textContent = 'Optional';
            document.getElementById('segmentStatus').style.color = '#6c757d';
            document.getElementById('segmentInfo').innerHTML = '';
            segmentDataJson = null;
        }
        
        // Run analysis
        function runAnalysis() {
            if (!maxdiffDataJson) {
                alert('Please load MaxDiff data first');
                return;
            }
            
            if (!pyodideReady) {
                alert('Python environment is still loading. Please wait.');
                return;
            }
            
            document.getElementById('runBtn').disabled = true;
            document.getElementById('runBtn').textContent = '‚è≥ Running...';
            document.getElementById('resultsContainer').classList.remove('show');
            document.getElementById('logContent').textContent = '';
            document.getElementById('downloadBtn').style.display = 'none';
            document.getElementById('segmentSelector').style.display = 'none';
            
            updateProgress(0, 'Starting analysis...');
            
            const options = {
                output_terms: document.getElementById('outputTerms').value,
                include_ci: document.getElementById('includeCI').checked,
                iterations: parseInt(document.getElementById('iterations').value) || 10000,
                anchor_item: document.getElementById('anchorItem').value.trim()
            };
            
            // Send to worker
            worker.postMessage({
                type: 'run',
                data: maxdiffDataJson,
                segmentData: segmentDataJson || [],
                options: options
            });
        }
        
        // Display results
        function displayResults() {
            document.getElementById('resultsContainer').classList.add('show');
            
            const dropdown = document.getElementById('segmentDropdown');
            dropdown.innerHTML = '<option value="overall">Overall (All Respondents)</option>';
            
            const segmentColumns = analysisResults.segment_columns || [];
            const segments = analysisResults.segments || {};
            
            let hasSegments = false;
            
            for (const column of segmentColumns) {
                if (segments[column]) {
                    for (const segValue of Object.keys(segments[column])) {
                        hasSegments = true;
                        const optionValue = `${column}|||${segValue}`;
                        const optionText = `${column}: ${segValue} (n=${segments[column][segValue].sample_size})`;
                        dropdown.innerHTML += `<option value="${optionValue}">${optionText}</option>`;
                    }
                }
            }
            
            document.getElementById('segmentSelector').style.display = hasSegments ? 'block' : 'none';
            
            currentSegmentView = 'overall';
            displaySegmentResults('overall');
            
            updateProgress(1, '‚úÖ Analysis complete!');
        }
        
        function switchSegmentView() {
            const dropdown = document.getElementById('segmentDropdown');
            currentSegmentView = dropdown.value;
            displaySegmentResults(currentSegmentView);
        }
        
        function displaySegmentResults(segmentKey) {
            let data;
            let infoText = '';
            
            if (segmentKey === 'overall') {
                data = analysisResults.overall;
                infoText = `n = ${data.sample_size}`;
            } else {
                const [column, value] = segmentKey.split('|||');
                data = analysisResults.segments[column][value];
                infoText = `n = ${data.sample_size}`;
            }
            
            document.getElementById('currentSegmentInfo').textContent = infoText;
            
            document.getElementById('scoresChart').innerHTML = 
                `<img src="data:image/png;base64,${data.scores_chart}" alt="Scores Chart">`;
            document.getElementById('frequenciesChart').innerHTML = 
                `<img src="data:image/png;base64,${data.frequencies_chart}" alt="Frequencies Chart">`;
            document.getElementById('balanceChart').innerHTML = 
                `<img src="data:image/png;base64,${data.balance_chart}" alt="Balance Chart">`;
            
            document.getElementById('scoresTable').innerHTML = createTable(data.scores_data);
            document.getElementById('displayTable').innerHTML = createTable(data.display_data);
        }
        
        function createTable(data) {
            if (!data || data.length === 0) return '<p>No data</p>';
            
            if (data instanceof Map) {
                data = Array.from(data.values());
            }
            
            data = data.map(item => {
                if (item instanceof Map) {
                    return Object.fromEntries(item);
                }
                return item;
            });
            
            const headers = Object.keys(data[0]);
            let html = '<div style="overflow-x: auto;"><table class="data-table"><thead><tr>';
            
            headers.forEach(h => {
                html += `<th>${h}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            data.forEach(row => {
                html += '<tr>';
                headers.forEach(h => {
                    let val = row[h];
                    if (typeof val === 'number') {
                        val = val.toFixed(2);
                    }
                    html += `<td>${val}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            return html;
        }
        
        function showTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.result-panel').forEach(panel => panel.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById('panel-' + tabName).classList.add('active');
        }
        
        function getCurrentSegmentData() {
            if (currentSegmentView === 'overall') {
                return analysisResults.overall;
            } else {
                const [column, value] = currentSegmentView.split('|||');
                return analysisResults.segments[column][value];
            }
        }
        
        function downloadCSV(type) {
            if (!analysisResults) return;
            
            const currentData = getCurrentSegmentData();
            let data, filename;
            
            const segmentSuffix = currentSegmentView === 'overall' ? 'overall' : 
                currentSegmentView.replace('|||', '_').replace(/[^a-zA-Z0-9_]/g, '_');
            
            if (type === 'scores') {
                data = currentData.scores_data;
                filename = `maxdiff_scores_${segmentSuffix}.csv`;
            } else if (type === 'frequencies') {
                data = currentData.frequencies_data;
                filename = `selection_frequencies_${segmentSuffix}.csv`;
            } else if (type === 'display') {
                data = currentData.display_data;
                filename = `display_statistics_${segmentSuffix}.csv`;
            }
            
            if (data instanceof Map) {
                data = Array.from(data.values());
            }
            data = data.map(item => item instanceof Map ? Object.fromEntries(item) : item);
            
            const csv = convertToCSV(data);
            downloadFile(csv, filename, 'text/csv');
        }
        
        function convertToCSV(data) {
            if (!data || data.length === 0) return '';
            
            const headers = Object.keys(data[0]);
            let csv = headers.join(',') + '\n';
            
            data.forEach(row => {
                csv += headers.map(h => {
                    let val = row[h];
                    if (val === null || val === undefined) val = '';
                    if (typeof val === 'string' && (val.includes(',') || val.includes('"'))) {
                        val = `"${val.replace(/"/g, '""')}"`;
                    }
                    return val;
                }).join(',') + '\n';
            });
            
            return csv;
        }
        
        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function downloadAllResults() {
            if (!analysisResults) return;
            
            currentSegmentView = 'overall';
            downloadCSV('scores');
            
            let delay = 300;
            
            const segmentColumns = analysisResults.segment_columns || [];
            const segments = analysisResults.segments || {};
            
            for (const column of segmentColumns) {
                if (segments[column]) {
                    for (const segValue of Object.keys(segments[column])) {
                        setTimeout(() => {
                            currentSegmentView = `${column}|||${segValue}`;
                            downloadCSV('scores');
                        }, delay);
                        delay += 300;
                    }
                }
            }
            
            setTimeout(() => {
                currentSegmentView = 'overall';
                document.getElementById('segmentDropdown').value = 'overall';
            }, delay);
        }
        
        function downloadExampleMaxDiff() {
            const csv = `Response ID,Attribute1,Attribute2,Attribute3,Attribute4,Most,Least
R001,Price,Quality,Brand,Speed,Quality,Price
R001,Design,Support,Durability,Features,Features,Support
R001,Price,Brand,Durability,Speed,Price,Speed
R002,Quality,Brand,Support,Features,Quality,Support
R002,Price,Durability,Speed,Design,Speed,Price
R002,Design,Quality,Brand,Features,Quality,Design
R003,Brand,Speed,Design,Durability,Design,Brand
R003,Price,Quality,Support,Features,Quality,Price
R003,Support,Durability,Speed,Brand,Support,Brand
R004,Price,Quality,Brand,Design,Quality,Price
R004,Speed,Support,Durability,Features,Features,Support
R004,Price,Brand,Speed,Durability,Brand,Speed
R005,Quality,Design,Support,Features,Quality,Support
R005,Price,Brand,Durability,Speed,Price,Durability
R005,Design,Quality,Brand,Features,Quality,Design`;
            
            downloadFile(csv, 'example_maxdiff.csv', 'text/csv');
        }
        
        function downloadExampleSegment() {
            const csv = `Response ID,Gender,Age Group,Region
R001,Female,25-34,North
R002,Male,35-44,South
R003,Female,18-24,North
R004,Male,45-54,East
R005,Female,25-34,West`;
            
            downloadFile(csv, 'example_segments.csv', 'text/csv');
        }
        
        function toggleCollapsible(element) {
            element.classList.toggle('open');
            element.nextElementSibling.classList.toggle('show');
        }
        
        function showLoading(show, text) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.add('show');
                document.getElementById('loadingText').textContent = text || 'Loading...';
            } else {
                overlay.classList.remove('show');
            }
        }
        
        function updateProgress(value, status) {
            const percent = Math.round(value * 100);
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = Math.max(percent, 2) + '%';
            progressFill.textContent = percent + '%';
            if (status) {
                document.getElementById('progressStatus').textContent = status;
            }
        }
        
        function log(message, type) {
            const logContent = document.getElementById('logContent');
            let className = '';
            if (type === 'success') className = 'success';
            else if (type === 'error') className = 'error';
            else if (type === 'warning') className = 'warning';
            else if (type === 'info') className = 'info';
            
            const line = document.createElement('span');
            line.className = className;
            line.textContent = message + '\n';
            logContent.appendChild(line);
            logContent.scrollTop = logContent.scrollHeight;
        }
        
        // Initialize on page load
        window.addEventListener('load', initWorker);
    </script>
</body>
</html>
